const fs = require( 'fs' )
const props = require( './property_defs')

const headers = []
const body = []
const body_header = []
const fn = []
const prop_find = []
const registered_ids = {}
const prop_pointers = []

const body_prop_get_nth_value = 
`bool prop_get_nth_value( prop_t* prop, uint32_t idx, void* out_value ) {
  assert( prop );
  assert( out_value );
  if( idx >= prop->num_enums )
    return false;
  if( prop->data_type == PDT_U16 ) {
    assert( prop->enums_data );
    uint16_t* d = (uint16_t*) prop->enums_data;
    *(uint32_t*) out_value = (uint32_t) d[idx];
    return true;
  }
  if( prop->data_type == PDT_U32 ) {
    assert( prop->enums_data );
    uint32_t* d = (uint32_t*) prop->enums_data;
    *(uint32_t*) out_value = d[idx];
    return true;
  }
  return false;
}
`
const header_prop_get_nth_value = `bool prop_get_nth_value( prop_t* prop, uint32_t idx, void* out_value );`

headers.push( "#pragma once" )
headers.push( "" )
headers.push( `#include "connection.h"`)
headers.push( "" )
headers.push( "// This file is autogenerated" )
headers.push( "" )
headers.push( `const char* prop_get_value_str( prop_t* p );` )
headers.push( `const prop_t* prop_by_id( uint16_t prop_id );` )
headers.push( `const prop_t** prop_get_all( );` )
headers.push( header_prop_get_nth_value )


body_header.push( `#include <assert.h>`)
body_header.push( `#include "properties.h"`)
body_header.push( "" )
body_header.push( "// This file is autogenerated" )
body_header.push( "" )
body_header.push( body_prop_get_nth_value )

prop_pointers.push( 'const prop_t* props[] = {')


function add_extern_decl( name ) {
  headers.push( `\nextern const prop_t prop_${name};` );
}

function add_extern_value( c_name, value ) {
  headers.push( `#define ${c_name}  ${value}` );
}

function add_case( cval, str ) {
  fn.push( `      case ${cval}: return "${str}";` )
}

function get_keys( p ) {
  return p.filter( (v,idx) => {
    return (idx & 1) != 1
  });
}

function get_values( p ) {
  return p.filter( (v,idx) => {
    return (idx & 1) == 0
  });
}

function get_value( p, key ) {
  const idx = get_keys(p).indexOf( key );
  return p[ idx*2 + 1 ];
}

function export_prop( Name, p ) {
  // Name = Quality
  const NameId = Name.replace( / /g, "_")
  const name = NameId.toLowerCase()
  add_extern_decl( name )

  if( registered_ids[p.id] ) 
    throw( `Property id 0x${p.id} (${Name}) is already registered to property (${registered_ids[p.id]})`)
  registered_ids[ p.id ] = Name;

  const id_cval = `0x${p.id}`;
  const num_enums = p.values ? ( p.values.length / 2 ) : 0
  let enums_data_pointer = 0

  if( p.values ) {
    const pdt_c = p.dt == 'U32' ? 'uint32_t' : 'uint16_t'
    const enum_data_header = `const ${pdt_c} prop_${name}_values[] = { 0x`;
    const enum_data_values = get_keys( p.values ).join( ", 0x" );
    enums_data_pointer = `&prop_${name}_values`
    body.push( enum_data_header + enum_data_values + '};' )
  }

  body.push( `const prop_t prop_${name} = { .id = ${id_cval}, .name = "${Name}", .data_type = PDT_${p.dt},` )
  body.push( `                              .read_only = ${p.read_only ? true : false}, .ivalue = 0, `)
  body.push( `                              .blob = { .count = 0, .data = 0, .reserved = 0 }, `)
  body.push( `                              .num_enums = ${num_enums}, .enums_data = ${enums_data_pointer} };`)

  prop_find.push( `    case 0x${p.id}: return &prop_${name};` );

  prop_pointers.push( `&prop_${name},` )

  if( p.values ) {
    fn.push( `  case ${id_cval}: {  // ${name}\n      switch( p->ivalue ) {`)

    const def_name = `PDV_${NameId}`   // Prop_Exposure_Time_50secs
    add_extern_value( def_name, `0x${p.id}` )

    get_keys( p.values ).forEach( kval => {
      const Str = get_value( p.values, kval );
      const str_id = Str.replace( / /g, "_" ).replace( /[\.\/]/g, "_")
      const c_val = `0x${kval}`
      const c_name = `PDV_${NameId}_${str_id}`.padEnd( 32 )   // PDV_Exposure_Time_50secs
      add_extern_value( c_name, c_val )
      add_case( c_name, Str );
    })
    fn.push( `      default: break;`)
    fn.push( `    }`)
    fn.push( `    break;`)
    fn.push( `  }\n`)
  }

}

function save( lines, ofilename ) {
  const contents = lines.join( '\n' )
  console.log( contents )
  fs.writeFileSync( ofilename, contents );
}

function flush() {

  headers.push( "\n" )
  body.push( "\n" )
  console.log( ">>>>>>>>>>>> properties.h")
  save( headers, 'properties.h' )

  console.log( ">>>>>>>>>>>> properties.c")
  body_header.push( `const prop_t* prop_by_id( uint16_t prop_id ) {` )
  body_header.push( `  switch( prop_id ) {` )
  body_header.push( prop_find.join( "\n") )
  body_header.push( "    default: break;" )
  body_header.push( "  }" )
  body_header.push( "  return 0;" )
  body_header.push( "}\n" )

  body_header.push( `const char*   prop_get_value_str( prop_t* p ) {` )
  fn.push( `return "Unknown";\n}\n`)
  body_header.push( fn.join( "\n  " ) )

  prop_pointers.push( "0L   // End of array" )
  body.push( prop_pointers.join( "\n  ") )
  body.push( '};\n')
  body.push( `const prop_t** prop_get_all( ) { return props; }` )

  body_header.push( body.join( "\n" ) )

  save( body_header, 'properties.c' )
}

fn.push( `  switch( p->id ) {\n`)
Object.keys( props ).forEach( k => {
  export_prop( k, props[k] )
})
fn.push( `  default: break;\n  }`)

flush();
